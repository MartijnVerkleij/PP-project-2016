%------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%------------------------------------------------

\documentclass[twoside]{report}

\usepackage{graphicx}

\usepackage{minted}

\usepackage{amsmath,amssymb,amsthm} % Mathematical Symbols, styles, etc

\usepackage[sc]{mathpazo} % Use the Palatino font
% Output encoding
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
% Input encoding
\usepackage[utf8]{inputenc} % UTF-8 character encoding stuff
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF
\newcommand*{\fullref}[1]{\hyperref[{#1}]{\ref*{#1} (\nameref*{#1})}}
\newcommand*{\fullautoref}[1]{\hyperref[{#1}]{\autoref*{#1} (\nameref*{#1})}}

\usepackage{pdflscape} % For landscape pages

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
%\titleformat{\section}[block]{\large\scshape}{\thesection.}{1em}{} % Change the look of the section titles
%\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the subsection titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{M.F. Verkleij, T. Kerkhoven: \shorttitle} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

% Appendices
\usepackage[toc,page]{appendix} % appendix

% Additional column type
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

% Indentation of list
\usepackage{changepage}
\newenvironment{mycompactdesc}{\begin{adjustwidth}{0.53cm}{}\begin{compactdesc}}{\end{compactdesc}\end{adjustwidth}}

%------------------------------------------------
%	TITLE SECTION
%------------------------------------------------

\newcommand{\articletitle}{Programming Paradigms Final Project: Building a Compiler in Haskell for the Sprockell}
\newcommand{\shorttitle}{PP Final Project}

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{\articletitle}} % Article title

\author{
\large
\textsc{Group 26}\\[-0.75mm]
\textsc{Martijn Verkleij \& Tim Kerkhoven}\\[2mm] % Your name
\normalsize University of Twente \\ % Your institution
\normalsize \href{mailto:m.f.verkleij@student.utwente.nl}{m.f.verkleij@student.utwente.nl},
\href{mailto:t.kerkhoven@student.utwente.nl}{t.kerkhoven@student.utwente.nl}\\% Your email addresses
\normalsize s1466895 s1375253
}

\date{\today}

%------------------------------------------------

\begin{document}

\thispagestyle{empty}
\maketitle % Insert title


%------------------------------------------------
%	ARTICLE CONTENTS
%------------------------------------------------

%------------------------------------------------
\tableofcontents


%------------------------------------------------
\chapter{Introduction}
\label{introduction}
In the Programming Paradigms course, the final project is a combination of compiler construction, functional programming, and concurrent programming. It required the participants to build a compiler for a self-defined language to SprIL. The language had to support features, including basic concurrency.

The language group 26 designed for this project is called Simple Haskell Language (SHL), with file extension \emph{.shl}. It supports all the required features, as well as some additional features. These additional features include: procedures, and call-by-reference. The entire compiler runs on uses Haskell, both the code-generation and front end. The Sprockell was slightly extended as well.


%------------------------------------------------
\chapter{Summary}
\label{summary}
This chapter will give a summary of the features of SHL. 
\paragraph{Data types} SHL supports two types: integers and booleans. 
\paragraph{Simple expressions and variables} SHL supports denotations for primitive values of types as well as operations for (in)equality for values of types. SHL is strongly typed and all variables are initialised upon declaration. It also supports scoping with variable shadowing. The following expressions are supported:
\begin{compactitem}
	\item Parentheses
	\item Assignment
	\item Operation (with ==, !=, <>, \&\&, ||, <=, >=, <, >, +, -, *)
	\item Unary operation (with !, -)
	\item Variable
	\item Integer value
	\item Boolean value
\end{compactitem}
\paragraph{Basic statements} SHL supports the following statements: 
\begin{compactitem}
	\item Block
	\item Declaration
	\item If 
	\item While
	\item Call
	\item Fork 
	\item Join
	\item Print
	\item Expression
\end{compactitem}
\paragraph{Concurrency} SHL supports global variables, fork and join statements to implement concurrency.
\paragraph{Procedures} SHL supports basic procedures with call-by-reference.


%------------------------------------------------
\chapter{Problems \& Solutions}
\label{problems_and_solutions}
%TODO somewhere at the end

- Something about concurrency\\
- Something about call-by-reference\\
- Something about other stuff


%------------------------------------------------
\chapter{Sprockell Extensions}
\label{sprockell_extensions}
%TODO Martijn


%------------------------------------------------
\chapter{Detailed Language Description}
\label{detailed_language_description}
This chapter will describe every feature of SHL in detail: providing a basic description; information on the syntax with at least one example; usage information along with restrictions; a description of its effects and execution; and some general information on the generated code.


\subsection{Program}
\label{def:program}
\subsubsection*{Syntax}
\texttt{[GLOBAL]\ldots [PROCEDURE]\ldots [STATEMENTS]\ldots}\\
\begin{mycompactdesc}
	\item[GLOBAL] Global variable declarations as defined in \fullref{def:global}
	\item[PROCEDURE] Procedures as defined in \fullref{def:procedure}
	\item[STATEMENTS] Statements as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
global int number = 5;

procedure eq(int num1, int num2, bool out) {
	if ((num1 == num2)) {
		out = true;
	} else {
		out = false;
	}
}

int otherNumber = 6;
bool out;
eq(number, otherNumber, out);
print(out);
\end{minted}
\subsubsection*{Usage}
All files must follow the program syntax, and may only contain a single program.
\subsubsection*{Semantics}
A program is a collection of code which can be used to create an executable set of instructions. It is the root node of the Abstract Syntax Tree.
\subsubsection*{Code Generation}
%TODO Martijn

Any program is generally built up as follows:
\begin{compactitem}
	\item \textbf{Thread control code}
	\begin{compactitem}
		\item \textbf{Thread Control Loop} \\ All extra threads loop here, waiting to accept fork calls.
		\item \textbf{PreCall forked procedures} \\ Once a sprockell accepts a fork call, it reads the AR from global memory, and starts execution.
		\item \textbf{PostCall forked procedures} \\ Once an auxilary sprockell finishes the procedure, this code handles cleanup.
	\end{compactitem}
	\item \textbf{Procedures \ref{def:procedure}}
	\item \textbf{Global declarations \ref{def:global}}
	\item \textbf{Main code}
	
	\item \textbf{Post-program code} \\ Stops auxilary threads.
\end{compactitem}


\subsection{Global}
\label{def:global}
\subsubsection*{Syntax}
\texttt{global <TYPE> <ID> [= <EXPRESSION>] ;}
\begin{mycompactdesc}
	\item[TYPE] A type as defined in \fullref{def:types}
	\item[ID] A string as defined by \fullref{def:variable}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
global bool flag = true;
global int number;
\end{minted}
\subsubsection*{Usage}
Used to declare global variables and an optional assignment.  The type of the expression must match the type of the global variable.

All global variables MUST be defined at the top of the program, even before procedures.

The id of a global variable is unique in the whole program. No other variable of procedure may use the same id. They can therefore not be shadowed.
\subsubsection*{Semantics}
The global variable declaration reserves a space in shared memory and writes a value to it. All global variables are initialized to the default value (see \fullref{def:integer} and \fullref{def:boolean}) if no value is explicitly assigned.

Global variables are reachable from anywhere below its declaration in the code, in any thread. Beware, however, that the variable can be written to from any thread as well, and using the shared memory is significantly slower than using the local memory.

Globals that are passed as arguments to a procedure have their own intricacies, see \ref{def:call-by-refence} for more information.

\subsubsection*{Code Generation}
%TODO Martijn
All globals are saved in global memory. Writes and reads to globals are done atomically, but assignments are not. This avoids data races, but to ensure atomicity on the whole assignment, one must implement his own mutual exclusion.


\subsection{Procedure}
\label{def:procedure}
\subsubsection*{Syntax}
\texttt{procedure <ID> ( [<TYPE> <VAR>] [, <TYPE> <VAR>]\ldots ) <STATEMENT>...}
\begin{mycompactdesc}
	\item[ID] A string as defined in \fullref{def:variable}
	\item[TYPE] A type as defined in \fullref{def:types}
	\item[VAR] A variable as defined in \fullref{def:variable}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
procedure empty() print(0);
procedure other(int num, bool flip) {
	while ((num > 0)) {
		num = --num;
		flip = !flip;
	}
	print(num, flip);
}
\end{minted}
\subsubsection*{Usage}
Used to declare a procedure. Because call-by-reference (see \fullref{def:call-by-reference}) is used, a variable passed as an argument can be used to write resulting values. One could also use the global variables (see \fullref{def:global}), as they are accessible from everywhere.

The id of a procedure is unique in the whole program. No other variable of procedure may use the same id.
\subsubsection*{Semantics}
A procedure is section of code that can be executed from anywhere, using a call or fork statement (see \fullref{def:call} and \fullref{def:fork}) and passing the appropriate number of arguments to it.
\subsubsection*{Code Generation}
%TODO Martijn
Procedure code has the following structure:
\begin{compactitem}
	\item \textbf{PostCall code} \\ Copies all arguments into the local data area for use. 
	\item \textbf{Procedure's statements}
	\item \textbf{PreReturn code} \\ The final result of all arguments is read, and if they are global or local variables, saved to the appropriate location.
\end{compactitem}

\section{Statements}
\label{def:statements}


\subsection{Declaration}
\label{def:declaration}
\subsubsection*{Syntax}
\texttt{<TYPE> <ID> [= <EXPRESSION>] ;}
\begin{mycompactdesc}
	\item[TYPE] A type as defined in \fullref{def:types}
	\item[ID] A string as defined in \fullref{def:variable}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
int number = (1+1);
bool flag;
\end{minted}
\subsubsection*{Usage}
Used to declare local variables and an optional assignment. The type of the expression must match the type of the variable.

The id of a variable is unique in the scope it is defined in. No other variable in that scope may use the same id.
\subsubsection*{Semantics} %TODO Martijn, check this -- Done!
The variable declaration writes the value of the variable to the Local Data Area of where it was (most recently) defined. All variables are initialized to the default value (see \fullref{def:integer} and \fullref{def:boolean}) if no value is explicitly assigned.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{If}
\label{def:if}
\subsubsection*{Syntax}
\texttt{if ( <EXPRESSION> ) <STATEMENT> [else <STATEMENT>]}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
if (flag) {
	// do something
}
if (flag) print(flag); else {
	// do something
}
\end{minted}
\subsubsection*{Usage}
Execute a section of code based on an expression. The type of this expression must be a boolean.
\subsubsection*{Semantics}
If the expression evaluates to \emph{true}, execute the first statement. If it evaluates to \emph{false}, execute the code after the first statement, which can be either the second statement or the code that comes after the if statement.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{While}
\label{def:while}
\subsubsection*{Syntax}
\texttt{while ( <EXPRESSION> ) <STATEMENT>}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
while (flag) {
	// do something
}
\end{minted}
\subsubsection*{Usage}
Execute a section of code while the expression is \emph{true}. The type of this expression must be a boolean.
\subsubsection*{Semantics}
If the expression evaluates to \emph{true}, execute the statement. Repeat this for as long as the expression keeps evaluating to \emph{true}.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Fork}
\label{def:fork}
\subsubsection*{Syntax}
\texttt{fork <ID> ( [<EXPRESSION> [, <EXPRESSION>]\ldots] ) ;}
\begin{mycompactdesc}
	\item[ID] A string as defined by \fullref{def:variable}
	\item[EXPRESSION] An expression as defined by \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
fork proc0();
fork proc1(flag);
fork proc2(5, flag = true);
\end{minted}
\subsubsection*{Usage}
Run a procedure, which must have been declared somewhere, on a separate thread. The expression types must match the types defined during the procedure declaration (see \fullref{def:procedure}).
\subsubsection*{Semantics}
Writes the argument to shared memory and tells the thread pool to start parallel execution of the procedure.

Beware, if more procedures are given to the thread pool than there are threads, fork may have to wait for a thread to finish its work before continuing execution. In the case where only a single thread exists, this will cause the code to enter an infinite loop.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Join}
\label{def:join}
\subsubsection*{Syntax}
\texttt{join ;}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
join;
\end{minted}
\subsubsection*{Usage}
Ensures all thread have are done before continuing. May only be called in the main thread.
\subsubsection*{Semantics}
Blocks execution of the main thread until all other threads have finished their work.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Call}
\label{def:call}
\subsubsection*{Syntax}
\texttt{<ID> ( [<EXPRESSION> [, <EXPRESSION>]\ldots] ) ;}
\begin{mycompactdesc}
	\item[ID] A string as defined by \fullref{def:variable}
	\item[EXPRESSION] An expression as defined by \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
proc0();
proc1(flag);
proc2(5, flag = true);
\end{minted}
\subsubsection*{Usage}
Execute the called procedure, which must have been declared somewhere. The expressions must have the same types as the procedure as defined in its declaration (see \fullref{def:procedure})
\subsubsection*{Semantics}
Go to the procedure code and execute the procedure with the expressions, then return to the call.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Expression}
\label{def:expression_statement}
\subsubsection*{Syntax}
\texttt{<EXPRESSION> ;}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
a = (5 + (--6));
true;
-++++++++++a;
\end{minted}
\subsubsection*{Usage}
Allows expressions to be executed as statements, mostly for the purpose of enabling an assignment (see \fullref{def:assignment}) as a statement, since an assignment is an expression.
\subsubsection*{Semantics}
Execute the expression, this generally has no effects, except for an assignment.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Block}
\label{def:block}
\subsubsection*{Syntax}
\texttt{\{ [STATEMENT]\ldots \}}
\begin{mycompactdesc}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
{
	int i = 0;
	{
		i = ++i;
		{
			int i = 5;
		}
		print((i == 1));
	}
	print((i == 1));
}
\end{minted}
\subsubsection*{Usage}
A block is a single statement that contains zero or more statements. It is mostly used within procedures and statements to executes more than one statement.
\subsubsection*{Semantics}
A block opens a new scope, then executes the code within. When exiting a block, the scope is closed.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Print}
\label{def:print}
\subsubsection*{Syntax}
\texttt{print ( <EXPRESSION> [, <EXPRESSION>]\ldots ) ;}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
print(a);
print(true, 5, 1983);
print(a = ++a, ((11 - 2) * a));
\end{minted}
\subsubsection*{Usage}
Prints values of evaluated expressions to the console.
\subsubsection*{Semantics}
Evaluates the expressions and prints the values as they appear in memory, meaning a boolean is represented as either a zero (\emph{false}) or a one (\emph{true}).
\subsubsection*{Code Generation}
%TODO Martijn


\section{Expressions}
\label{def:expressions}


\subsection{Parentheses}
\label{def:parentheses}
\subsubsection*{Syntax}
\texttt{( <EXPRESSION> )}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
a = -(-(----a); // the same as: a = (-1) * (-1) * (a - 2);
\end{minted}
\subsubsection*{Usage}
Parentheses are used to enforce which operator is used (see the example above). It can also be used to enforce the order in which an expression is evaluated, but since this already explicitly happens (see \fullref{def:operation}) it should not be necessary to use a parentheses expression for it.
\subsubsection*{Semantics}
Everything between the parentheses is evaluated and the value is returned as the result of this expression.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Assignment}
\label{def:assignment}
\subsubsection*{Syntax}
\texttt{<ID> = <EXPRESSION>}
\begin{mycompactdesc}
	\item[ID] A string as defined in \fullref{def:variable}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
a = 5;
b = (c <> (d && e));
\end{minted}
\subsubsection*{Usage}
Used to assign a value, in the form of an expression, to a variable. The variable must have been declared beforehand, and may be either global or local.

The type of the expression must match the type of the variable.
\subsubsection*{Semantics}
Assignment evaluates the expression and writes it to the address of the variable.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Variable}
\label{def:variable}
\subsubsection*{Syntax}
\texttt{<ID>}
\begin{mycompactdesc}
	\item[ID] A string, starting with a letter, which may use any alphanumerical character in addition to the following characters: \emph{\~{}`'"@\#\$\textbackslash.?:\_{}}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
a
a@__b"42"\#1337'
\end{minted}
\subsubsection*{Usage}
A variable must be declared (see \fullref{def:declaration}) before use. It has a type which is determined upon declaration.
\subsubsection*{Semantics}
Evaluation of a variable returns its value.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Integer}
\label{def:integer}
\subsubsection*{Syntax}
\texttt{<INTEGER>}
\begin{mycompactdesc}
	\item[INTEGER] An integer string
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
42
1337
0000004201337
\end{minted}
\subsubsection*{Usage}
Takes the value of the integer, removes leading zeros.
\subsubsection*{Semantics}
Upon evaluation it returns its integer value.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Boolean}
\label{def:boolean}
\subsubsection*{Syntax}
\texttt{<BOOLEAN>}
\begin{mycompactdesc}
	\item[BOOLEAN] Where a boolean is either "\texttt{true}" or "\texttt{false}"
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
true
false
\end{minted}
\subsubsection*{Usage}
Takes the value of the boolean (either one or zero) and returns it.
\subsubsection*{Semantics}
Upon evaluation, return the corresponding binary representation of the boolean, where \emph{false} equals zero and \emph{true} equals one.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Operation}
\label{def:operation}
\subsubsection*{Syntax}
\texttt{( <EXPRESSION> <OPERATOR> <EXPRESSION> )}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
	\item[OPERATOR] One of the following operators: \texttt{==, !=, \&\&, ||, <>, <=, >=, <, >, +, -, *} (see \fullref{def:operators})
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
(true <> b)
((a + b) == (c + d))
\end{minted}
\subsubsection*{Usage}
Apply operator on two expressions. Both expressions must be of the same type, which must also match one of the types supported by the operator.
\subsubsection*{Semantics}
After both expressions have been evaluated, the operation is evaluated and its result will be returned.
\subsubsection*{Code Generation}
%TODO Martijn


\subsection{Unary Operation}
\label{def:unary_operation}
\subsubsection*{Syntax}
\texttt{<OPERATOR> <EXPRESSION>}
\begin{mycompactdesc}
	\item[OPERATOR] One of the following operators: \texttt{--, ++, -, !} (see \fullref{def:operators})
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
!b
-(--a)
---a // is the same as: --(-a)
\end{minted}
\subsubsection*{Usage}
Apply operator on the expression. The expression type must match one of the types supported by the operator.
\subsubsection*{Semantics}
After the expression has been evaluated, the operation is evaluated and its result will be returned.
\subsubsection*{Code Generation}
%TODO Martijn


\section{Other Features}
\label{def:other_features}


\subsection{Types}
\label{def:types}
\subsubsection*{Syntax}
\texttt{<TYPE>}
\begin{mycompactdesc}
	\item[TYPE] Either \texttt{int} or \texttt{bool}
\end{mycompactdesc}


\subsection{Operators}
\label{def:operators}
\subsubsection*{Syntax}
\texttt{<OPERATOR>}
\begin{mycompactdesc}
	\item[OPERATOR] One of the following: \texttt{==, !=, \&\&, ||, <>, <=, >=, <, >, +, -, *, --, ++, !}
\end{mycompactdesc}
\subsubsection*{Usage}
\begin{mycompactdesc}
	\item[OPERATOR] Operation: \texttt{supported types} $\rightarrow$ \texttt{return type}
	\item[==] equals: \texttt{int, bool} $\rightarrow$ \texttt{bool}
	\item[!=] not equals: \texttt{int, bool} $\rightarrow$ \texttt{bool}
	\item[\&\&] and: \texttt{bool} $\rightarrow$ \texttt{bool}
	\item[||] or: \texttt{bool} $\rightarrow$ \texttt{bool}
	\item[<>] xor: \texttt{bool} $\rightarrow$ \texttt{bool}
	\item[<=] lesser than or equals: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[>=] greater than or equals: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[<] lesser than: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[>] greater than: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[+] add: \texttt{int} $\rightarrow$ \texttt{int}
	\item[-] subtract: \texttt{int} $\rightarrow$ \texttt{int}
	\item[*] multiply: \texttt{int} $\rightarrow$ \texttt{int}
	\item[--] decrement: \texttt{int} $\rightarrow$ \texttt{int}
	\item[++] increment: \texttt{int} $\rightarrow$ \texttt{int}
	\item[!] not: \texttt{bool} $\rightarrow$ \texttt{bool}
\end{mycompactdesc}
Beware that using decrement and increment on a variable does not assign the new value to the variable as some other languages might do.


\subsection{Call-by-reference}
\label{def:call-by-refence}
%TODO Martijn


\subsection{Error Handling}
\label{def:error_handling}
The SHL compiler does not support proper exception handling, but does throw errors of varying usefulness. During the tokenising phase, the only error thrown is an illegal character error.

During the parsing phase, the only error which might be thrown is a token list not fully parsed error, indicating the grammar cannot parse the token list.

The checker phase thrown different kinds of errors, all related to context constraints, they generally indicate the function which throws the error as well as printing some of the responsible data.

The code generation and runtime phases thrown the following kinds of errors:
%TODO Martijn, beschrijf kort de error handling van de codegen

%------------------------------------------------
\chapter{Description of the Software}
\label{description_of_the_software}
The compiler consists of a number of haskell files, and some additional files. This chapter will go over the functions of each of those files.

\section{ASTBuilder.hs}
The purpose of the ASTBuilder is to build an Abstract Syntax Tree using a parsetree. The ASTBuilder also contains the functions to convert an AST to a RoseTree with or without debug information.

\section{BasicFunctions.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{Checker.hs}
The checker does type checking on an AST and adds information about scopes (symboltable) to it. It works in two passes, first collecting information about global variables and procedures, then checking for all context constraints.

\section{CodeGen.hs}
CodeGen takes a checked AST and generates a set of SprIL instructions. %TODO Martijn, is this enough, do you wish to elaborate?

\section{Constants.hs}
Constants stores constant values used in the code generation. %TODO Martijn, is this enough, do you wish to elaborate?

\section{FP\_{}ParserGen.hs}
Parser generator supplied by the course.

\section{Grammar.hs}
Grammar contains the grammar used in the compiler.

\section{HardwareTypes.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{Main.hs}
Main file, used for compilation and execution of SHL programs. Read the README.md for information on how to use it.

\section{README.md}
Constains some information about the project in general (eg. the Trello board) and instructions on how to use the compiler.

\section{Simulation.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{Sprockell.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{System.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{Test.hs}
Used for internal testing, contains functions to print and write debug information, show ASTs with and without debug information, show the parse tree, and show the token list.

\section{Tokenizer.hs}
Tokenizer tokenises a string into a list of tokens.

\section{Types.hs}
Contains all the Haskell types used during compilation, including Alphabet, AST, and checking/scope types.


%------------------------------------------------
\chapter{Test Plan \& Results}
\label{test_plan_and_results}


\section{Implemented Tests}
\label{implemented_tests}
Following is a list of all the test files that have been used to test the compiler, and a short description of their purpose.
\begin{mycompactdesc}
    \item[cyclic\_{}recursion] Tests for correct cyclic recursion
    \item[deep\_{}expression] Tests for correct evaluation of nested expressions
    \item[fib] Tests for correct evaluation of a Fibonacci procedure 
    \item[if] Tests a correct simple if statement
    \item[ifelse] Tests a correct simple if-else statement
    \item[infinite\_{}busy\_{}loop] Tests behaviour in an empty infinite loop
    \item[infinite\_{}loop] Tests behaviour in an infinite loop with some operation in it. Also tests integer overflows, which are not detected.
    \item[nested\_{}procedures] Tests for correct evaluation of nested procedures
    \item[recursion] Tests for correct recursion
    \item[while] Tests a simple correct while statement
    \item[call\_{}by\_{}reference] Tests for correct multi-threaded call-by-reference
    \item[blocks] Tests for correct handling of scopes
    \item[simple\_{}proc] Tests a simple correct procedure
	\item[banking] Tests a concurrent banking application
    \item[peterson] Tests for correct evaluation of Peterson's algorithm
    \item[simple\_{}concurrency] Tests a simple correct concurrent program
    \item[multiple\_{}globals] Tests behaviour of concurrent printing of global variables
    \item[join\_{}test] Tests whether join behaviour is correct
\end{mycompactdesc}


\section{Test Plan}
The testing has been roughly divided into three cases: syntax, context constraints and semantics. For the first two phases most of the testing of correct code occurs during the semantic testing and as informal testing during the building of those parts of the compiler. Some test files have been made to more formally test the incorrect code.

The shape of the parse tree and Abstract Syntax Tree have been extensively observed and checked during the building of the checking part of the compiler. This has mostly been done by slightly tweaking a program a multitude of times, to produce all intended shapes of the tree and attempting to produce unintended shapes, and building the trees. This part of the testing, as well as the previous part, have not been documented very well, and might therefore appear somewhat lacking compared to the semantic testing.

The semantics, or run-time, testing has been given the most time and effort, and checks for correctness of code generation and intended behaviour. Since very little run-time error are thrown (see \fullref{def:error_handling}), there are only a few tests of incorrect code, or code producing unintended effects.


\section{How To Run a Test}
\label{how_to_run_a_test}
To run a test, simply follow the \texttt{README.md}, using the following path: \texttt{test/<fileName>}, where \texttt{fileName} is one of the tests described above. Remember that for a concurrent program, which is any program that uses at least one fork statement, multiple Sprockells have to be used.


%------------------------------------------------
\chapter{Personal Evaluation}
\label{personal_evaluation}
\section{Martijn}
%TODO somewhere at the end by Martijn
\section{Tim}
%TODO somewhere at the end by Tim


%------------------------------------------------
%	APPENDICES
%------------------------------------------------
\begin{appendices}
\label{appendices}


%------------------------------------------------
\chapter{Grammar Specification}
\label{grammar_specification}
\begin{landscape}
\inputminted[firstline=66, lastline=138, tabsize=4]{haskell}{../Grammar.hs}
\end{landscape}


%------------------------------------------------
\chapter{Extended Test Program}
\label{extended_test_program}
The extended test program shown here is Peterson's algorithm. It shows how, using the available methods for concurrency, two thread using the same variable have mutually exclusive access to it.

\section{Peterson's Algorithm Test}
\inputminted[tabsize=4]{text}{../test/peterson.shl}

\section{Generated Code}
\begin{minted}[tabsize=4,linenos,firstnumber=0]{text}
Compute Equal 1 0 6
Branch 6 (Rel 2)
Jump (Rel 7)
TestAndSet (DirAddr 2)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
Load (ImmValue 0) 7
Jump (Rel 630)
ReadInstr (DirAddr 0)
Receive 3
Compute Equal 3 0 6
Branch 6 (Rel 2)
EndProg
TestAndSet (DirAddr 2)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-8))
ComputeI Add 1 30 3
TestAndSet (IndAddr 3)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
ReadInstr (DirAddr 3)
Receive 3
Push 3
ComputeI Add 7 1 4
ReadInstr (DirAddr 4)
Receive 5
Load (ImmValue 5) 2
Compute Equal 5 0 6
Branch 6 (Rel 18)
ReadInstr (IndAddr 2)
Receive 3
Store 3 (IndAddr 4)
Compute Incr 2 0 2
Compute Incr 4 0 4
ReadInstr (IndAddr 2)
Receive 3
Store 3 (IndAddr 4)
Compute Incr 2 0 2
Compute Incr 4 0 4
ReadInstr (IndAddr 2)
Receive 3
Store 3 (IndAddr 4)
Compute Incr 2 0 2
Compute Incr 4 0 4
Compute Decr 5 0 5
Jump (Rel (-18))
Load (ImmValue 57) 5
Store 5 (IndAddr 4)
Compute Incr 4 0 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
Pop 2
WriteInstr 0 (DirAddr 1)
Jump (Ind 2)
ComputeI Add 1 30 3
WriteInstr 0 (IndAddr 3)
Jump (Abs 9)
Load (ImmValue 1) 2
Compute Sub 7 2 2
Load (ImmValue 1) 5
ComputeI Gt 5 0 6
Branch 6 (Rel 7)
Load (IndAddr 2) 3
Compute Add 7 5 6
Store 3 (IndAddr 6)
Compute Incr 5 0 5
ComputeI Add 2 3 2
Jump (Rel (-7))
Compute Add 7 0 4
ComputeI Add 4 1 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
Load (ImmValue 1) 6
Push 6
Load (ImmValue 33) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 34) 4
Pop 6
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Pop 0
Load (ImmValue 1) 6
Push 6
Load (ImmValue 39) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 40) 4
Pop 6
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Pop 0
Load (ImmValue 35) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 36) 4
ReadInstr (IndAddr 4)
Receive 5
Push 5
WriteInstr 0 (IndAddr 2)
Load (ImmValue 39) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 40) 4
ReadInstr (IndAddr 4)
Receive 5
Push 5
WriteInstr 0 (IndAddr 2)
Load (ImmValue 1) 6
Push 6
Pop 3
Pop 2
Compute Equal 2 3 4
Push 4
Pop 3
Pop 2
Compute And 2 3 4
Push 4
Pop 6
ComputeI Xor 6 1 6
Branch 6 (Rel 7)
Compute Add 7 0 4
ComputeI Add 4 1 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
Load (IndAddr 7) 7
Jump (Rel (-38))
Load (ImmValue 5) 6
Push 6
Compute Add 7 0 6
ComputeI Add 6 1 6
Pop 5
Store 5 (IndAddr 6)
Compute Add 7 0 6
ComputeI Add 6 1 6
Load (IndAddr 6) 5
Push 5
Load (ImmValue 0) 6
Push 6
Pop 3
Pop 2
Compute Gt 2 3 4
Push 4
Pop 6
ComputeI Xor 6 1 6
Branch 6 (Rel 45)
Compute Add 7 0 4
ComputeI Add 4 2 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
Load (ImmValue 37) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 38) 4
ReadInstr (IndAddr 4)
Receive 5
Push 5
WriteInstr 0 (IndAddr 2)
Pop 2
Compute Incr 2 0 4
Push 4
Load (ImmValue 37) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 38) 4
Pop 6
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Pop 0
Compute Add 7 0 6
Load (IndAddr 6) 6
ComputeI Add 6 1 6
Load (IndAddr 6) 5
Push 5
Pop 2
Compute Decr 2 0 4
Push 4
Compute Add 7 0 6
Load (IndAddr 6) 6
ComputeI Add 6 1 6
Pop 2
Store 2 (IndAddr 6)
Push 2
Pop 0
Load (IndAddr 7) 7
Jump (Rel (-56))
Load (ImmValue 0) 6
Push 6
Load (ImmValue 33) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 34) 4
Pop 6
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Pop 0
Load (IndAddr 7) 7
Load (ImmValue 0) 2
Compute Sub 7 2 2
ComputeI Add 0 1 5
ComputeI Gt 5 0 6
Branch 6 (Rel 23)
Compute Add 7 5 6
Load (IndAddr 6) 4
Load (IndAddr 2) 3
Compute Lt 3 0 6
Branch 6 (Rel 2)
Store 4 (IndAddr 3)
Compute Incr 2 0 2
Load (IndAddr 2) 3
Compute Lt 3 0 6
Branch 6 (Rel 10)
Compute Add 3 0 6
TestAndSet (IndAddr 6)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-4))
ComputeI Add 3 1 3
WriteInstr 4 (IndAddr 3)
ComputeI Sub 3 1 3
WriteInstr 0 (IndAddr 3)
Compute Incr 5 0 5
ComputeI Add 2 2 2
Jump (Rel (-23))
Compute Decr 7 0 2
Load (IndAddr 2) 6
Load (IndAddr 7) 7
Jump (Ind 6)
Load (ImmValue 1) 2
Compute Sub 7 2 2
Load (ImmValue 1) 5
ComputeI Gt 5 0 6
Branch 6 (Rel 7)
Load (IndAddr 2) 3
Compute Add 7 5 6
Store 3 (IndAddr 6)
Compute Incr 5 0 5
ComputeI Add 2 3 2
Jump (Rel (-7))
Compute Add 7 0 4
ComputeI Add 4 1 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
Load (ImmValue 1) 6
Push 6
Load (ImmValue 35) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 36) 4
Pop 6
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Pop 0
Load (ImmValue 0) 6
Push 6
Load (ImmValue 39) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 40) 4
Pop 6
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Pop 0
Load (ImmValue 33) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 34) 4
ReadInstr (IndAddr 4)
Receive 5
Push 5
WriteInstr 0 (IndAddr 2)
Load (ImmValue 39) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 40) 4
ReadInstr (IndAddr 4)
Receive 5
Push 5
WriteInstr 0 (IndAddr 2)
Load (ImmValue 0) 6
Push 6
Pop 3
Pop 2
Compute Equal 2 3 4
Push 4
Pop 3
Pop 2
Compute And 2 3 4
Push 4
Pop 6
ComputeI Xor 6 1 6
Branch 6 (Rel 7)
Compute Add 7 0 4
ComputeI Add 4 1 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
Load (IndAddr 7) 7
Jump (Rel (-38))
Load (ImmValue 5) 6
Push 6
Compute Add 7 0 6
ComputeI Add 6 1 6
Pop 5
Store 5 (IndAddr 6)
Compute Add 7 0 6
ComputeI Add 6 1 6
Load (IndAddr 6) 5
Push 5
Load (ImmValue 0) 6
Push 6
Pop 3
Pop 2
Compute Gt 2 3 4
Push 4
Pop 6
ComputeI Xor 6 1 6
Branch 6 (Rel 45)
Compute Add 7 0 4
ComputeI Add 4 2 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
Load (ImmValue 37) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 38) 4
ReadInstr (IndAddr 4)
Receive 5
Push 5
WriteInstr 0 (IndAddr 2)
Pop 2
Compute Decr 2 0 4
Push 4
Load (ImmValue 37) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 38) 4
Pop 6
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Pop 0
Compute Add 7 0 6
Load (IndAddr 6) 6
ComputeI Add 6 1 6
Load (IndAddr 6) 5
Push 5
Pop 2
Compute Decr 2 0 4
Push 4
Compute Add 7 0 6
Load (IndAddr 6) 6
ComputeI Add 6 1 6
Pop 2
Store 2 (IndAddr 6)
Push 2
Pop 0
Load (IndAddr 7) 7
Jump (Rel (-56))
Load (ImmValue 0) 6
Push 6
Load (ImmValue 35) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 36) 4
Pop 6
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Pop 0
Load (IndAddr 7) 7
Load (ImmValue 0) 2
Compute Sub 7 2 2
ComputeI Add 0 1 5
ComputeI Gt 5 0 6
Branch 6 (Rel 23)
Compute Add 7 5 6
Load (IndAddr 6) 4
Load (IndAddr 2) 3
Compute Lt 3 0 6
Branch 6 (Rel 2)
Store 4 (IndAddr 3)
Compute Incr 2 0 2
Load (IndAddr 2) 3
Compute Lt 3 0 6
Branch 6 (Rel 10)
Compute Add 3 0 6
TestAndSet (IndAddr 6)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-4))
ComputeI Add 3 1 3
WriteInstr 4 (IndAddr 3)
ComputeI Sub 3 1 3
WriteInstr 0 (IndAddr 3)
Compute Incr 5 0 5
ComputeI Add 2 2 2
Jump (Rel (-23))
Compute Decr 7 0 2
Load (IndAddr 2) 6
Load (IndAddr 7) 7
Jump (Ind 6)
Load (ImmValue 4) 2
Compute Sub 7 2 2
Load (ImmValue 1) 5
ComputeI Gt 5 1 6
Branch 6 (Rel 7)
Load (IndAddr 2) 3
Compute Add 7 5 6
Store 3 (IndAddr 6)
Compute Incr 5 0 5
ComputeI Add 2 3 2
Jump (Rel (-7))
Compute Add 7 0 4
ComputeI Add 4 2 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
Compute Add 7 0 6
Load (IndAddr 6) 6
ComputeI Add 6 1 6
Load (IndAddr 6) 5
Push 5
Load (ImmValue 0) 6
Push 6
Pop 3
Pop 2
Compute Gt 2 3 4
Push 4
Pop 6
ComputeI Xor 6 1 6
Branch 6 (Rel 148)
Compute Add 7 0 4
ComputeI Add 4 1 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
TestAndSet (DirAddr 1)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
Load (ImmValue 5) 4
Load (ImmValue 0) 5
WriteInstr 5 (DirAddr 4)
Load (ImmValue 60) 6
Push 6
Pop 5
WriteInstr 5 (DirAddr 3)
WriteInstr 0 (DirAddr 2)
Load (ImmValue 1) 3
ReadInstr (IndAddr 3)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
TestAndSet (DirAddr 1)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
Load (ImmValue 5) 4
Load (ImmValue 0) 5
WriteInstr 5 (DirAddr 4)
Load (ImmValue 245) 6
Push 6
Pop 5
WriteInstr 5 (DirAddr 3)
WriteInstr 0 (DirAddr 2)
Load (ImmValue 1) 3
ReadInstr (IndAddr 3)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
Compute Equal 0 1 6
Branch 6 (Rel 4)
Load (ImmValue 2) 2
PrintOut 2
EndProg
Load (ImmValue 30) 3
Load (ImmValue 0) 2
ReadInstr (IndAddr 3)
Receive 4
Compute Add 2 4 2
ComputeI NEq 3 33 6
Compute Incr 3 0 3
Branch 6 (Rel (-5))
Compute Equal 2 0 6
Branch 6 (Rel 2)
Jump (Rel (-10))
Load (ImmValue 37) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 38) 4
ReadInstr (IndAddr 4)
Receive 5
Push 5
WriteInstr 0 (IndAddr 2)
Pop 6
PrintOut 6
TestAndSet (DirAddr 1)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
Load (ImmValue 5) 4
Load (ImmValue 0) 5
WriteInstr 5 (DirAddr 4)
Load (ImmValue 245) 6
Push 6
Pop 5
WriteInstr 5 (DirAddr 3)
WriteInstr 0 (DirAddr 2)
Load (ImmValue 1) 3
ReadInstr (IndAddr 3)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
TestAndSet (DirAddr 1)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
Load (ImmValue 5) 4
Load (ImmValue 0) 5
WriteInstr 5 (DirAddr 4)
Load (ImmValue 60) 6
Push 6
Pop 5
WriteInstr 5 (DirAddr 3)
WriteInstr 0 (DirAddr 2)
Load (ImmValue 1) 3
ReadInstr (IndAddr 3)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-3))
Compute Equal 0 1 6
Branch 6 (Rel 4)
Load (ImmValue 2) 2
PrintOut 2
EndProg
Load (ImmValue 30) 3
Load (ImmValue 0) 2
ReadInstr (IndAddr 3)
Receive 4
Compute Add 2 4 2
ComputeI NEq 3 33 6
Compute Incr 3 0 3
Branch 6 (Rel (-5))
Compute Equal 2 0 6
Branch 6 (Rel 2)
Jump (Rel (-10))
Load (ImmValue 37) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-4))
Load (ImmValue 38) 4
ReadInstr (IndAddr 4)
Receive 5
Push 5
WriteInstr 0 (IndAddr 2)
Pop 6
PrintOut 6
Compute Add 7 0 6
Load (IndAddr 6) 6
Load (IndAddr 6) 6
ComputeI Add 6 1 6
Load (IndAddr 6) 5
Push 5
Pop 2
Compute Decr 2 0 4
Push 4
Compute Add 7 0 6
Load (IndAddr 6) 6
Load (IndAddr 6) 6
ComputeI Add 6 1 6
Pop 2
Store 2 (IndAddr 6)
Push 2
Pop 0
Load (IndAddr 7) 7
Jump (Rel (-160))
Load (IndAddr 7) 7
Load (ImmValue 3) 2
Compute Sub 7 2 2
ComputeI Add 0 1 5
ComputeI Gt 5 1 6
Branch 6 (Rel 23)
Compute Add 7 5 6
Load (IndAddr 6) 4
Load (IndAddr 2) 3
Compute Lt 3 0 6
Branch 6 (Rel 2)
Store 4 (IndAddr 3)
Compute Incr 2 0 2
Load (IndAddr 2) 3
Compute Lt 3 0 6
Branch 6 (Rel 10)
Compute Add 3 0 6
TestAndSet (IndAddr 6)
Receive 6
Branch 6 (Rel 2)
Jump (Rel (-4))
ComputeI Add 3 1 3
WriteInstr 4 (IndAddr 3)
ComputeI Sub 3 1 3
WriteInstr 0 (IndAddr 3)
Compute Incr 5 0 5
ComputeI Add 2 2 2
Jump (Rel (-23))
Compute Decr 7 0 2
Load (IndAddr 2) 6
Load (IndAddr 7) 7
Jump (Ind 6)
Load (ImmValue 0) 6
Push 6
Pop 6
Load (ImmValue 33) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-3))
Load (ImmValue 34) 4
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Load (ImmValue 0) 6
Push 6
Pop 6
Load (ImmValue 35) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-3))
Load (ImmValue 36) 4
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Load (ImmValue 0) 6
Push 6
Pop 6
Load (ImmValue 39) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-3))
Load (ImmValue 40) 4
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Load (ImmValue 0) 6
Push 6
Pop 6
Load (ImmValue 37) 2
TestAndSet (IndAddr 2)
Receive 3
Branch 3 (Rel 2)
Jump (Rel (-3))
Load (ImmValue 38) 4
WriteInstr 6 (IndAddr 4)
WriteInstr 0 (IndAddr 2)
Load (ImmValue 10) 6
Push 6
Compute Add 7 0 4
ComputeI Add 4 1 4
Load (ImmValue 1) 5
Pop 3
Store 3 (IndAddr 4)
Compute Incr 4 0 4
Load (ImmValue (-1)) 3
Store 3 (IndAddr 4)
Compute Incr 4 0 4
Load (ImmValue (-1)) 3
Store 3 (IndAddr 4)
Compute Incr 4 0 4
Load (ImmValue 707) 6
Push 6
Pop 5
Store 5 (IndAddr 4)
Compute Incr 4 0 4
Store 7 (IndAddr 4)
Compute Add 4 0 7
Load (ImmValue 430) 6
Push 6
Pop 2
Jump (Ind 2)
Load (ImmValue 1) 2
WriteInstr 2 (DirAddr 0)
EndProg
\end{minted}

\section{Correct Executions}
Every time a value is printed in Peterson's algorithm test, it should be zero:
\begin{minted}[tabsize=4]{text}
What file do you want to run? Please provide the relative path excluding the extension.
test/peterson
How many Sprockells do you want to use to run this file?
3
Running: test/peterson.shl
On 3 Sprockells
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
\end{minted}


\end{appendices}

\end{document}
